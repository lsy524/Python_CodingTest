# 1이 될 때끼지 
'''
* 문제 해결 아이디어 
    - 주어진 N에 대하여 최대한 많이 나누기를 수행
    - N의 값을 줄일 때 2이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄임
'''

# 내가 푼 풀이 
n, k = map(int, input().split()) # n, k를 공백 기준으로 입력받고 map함수를 통해 int형으로 형변환
result = 0

while True :
    # n이 k로 나누어 질 경우 
    if n % k == 0 : 
        n //= k     # n은 n과 k로 나눈 몫을 대입 
        result += 1 # result에 1을 더함 
    # n이 k로 나누어 지지 않을 경우 
    else :
        n -= 1      # n은 n에서 -1을 한 값을 대입 
        result += 1 # result에 1을 더함 

    # n이 1일 경우 => 모두 수행한 경우 
    if n == 1:
        break       # 반복문 빠져나옴 

print(result)

#======================================================================

# 답안 예시 
'''
위의 코드보다 좋은 점은 한번 반복이 될때마다 N이 K로 나누어 떨어지는 연산이 수행되기 때문에
반복 횟수에 따라서 기하급수적으로 N이 빠르게 줄어들게됨
즉, 시간복잡도가 log시간이 될 수 있음
'''
N, K = map(int, input().split())
result2 = 0

while True :
    # N을 K로 나누어 떠어지는 수가 될 때까지 빼기
    target = (N // K) * K   # N이 K로 나누어 떨어지지 않는 다면 가장 가까운 수가 대입
    result2 += (N - target)
    N = target

    # N이 K보다 작을 때(더 이상 나눌 수 없을 때) 반복문 탈출
    if N < K :
        break
    
    # K로 나누기 
    N //= K
    result2 += 1

# 마지막으로 남은 수에 대하여 1씩 빼기
result2 += (N - 1)
print(result2)
